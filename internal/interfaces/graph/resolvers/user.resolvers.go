package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"blogThree/internal/interfaces/graph"
	"blogThree/internal/interfaces/graph/model"
	"blogThree/internal/interfaces/httpctx"
	"context"
	"fmt"
	"net/http"
)

// SignUp is the resolver for the signUp field.
func (r *mutationResolver) SignUp(ctx context.Context, input model.SignUpInput) (*model.User, error) {
	user, err := r.UserSvc.SignUp(ctx, input.Email, input.Password)
	if err != nil {
		return nil, err
	}
	return toUserModel(user), nil
}

// SignIn is the resolver for the signIn field.
func (r *mutationResolver) SignIn(ctx context.Context, input model.SignInInput) (*model.AuthPayload, error) {
	user, err := r.UserSvc.SignIn(ctx, input.Email, input.Password)
	if err != nil {
		return nil, err
	}

	tokens, err := r.AuthSvc.GenerateForUser(ctx, user.ID())
	if err != nil {
		return nil, err
	}

	if w, ok := httpctx.ResponseWriter(ctx); ok {
		http.SetCookie(w, &http.Cookie{
			Name:     "refresh_token",
			Value:    tokens.RefreshToken,
			HttpOnly: true,
			Secure:   true,
			SameSite: http.SameSiteStrictMode,
			Path:     "/",
		})
	}

	return &model.AuthPayload{
		User:        toUserModel(user),
		AccessToken: tokens.AccessToken.Value,
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context) (*model.AuthPayload, error) {
	req, ok := httpctx.Request(ctx)
	if !ok {
		return nil, fmt.Errorf("no request in context")
	}

	c, err := req.Cookie("refresh_token")
	if err != nil || c.Value == "" {
		return nil, fmt.Errorf("no refresh token")
	}

	tokens, userID, err := r.AuthSvc.Refresh(ctx, c.Value)
	if err != nil {
		return nil, err
	}

	user, err := r.UserSvc.GetByID(ctx, userID)
	if err != nil {
		return nil, err
	}

	if w, ok := httpctx.ResponseWriter(ctx); ok {
		http.SetCookie(w, &http.Cookie{
			Name:     "refresh_token",
			Value:    tokens.RefreshToken,
			HttpOnly: true,
			Secure:   true,
			SameSite: http.SameSiteStrictMode,
			Path:     "/",
		})
	}

	return &model.AuthPayload{
		User:        toUserModel(user),
		AccessToken: tokens.AccessToken.Value,
	}, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	dbUsers, err := r.UserSvc.ListUsers(ctx)
	if err != nil {
		return nil, err
	}

	users := make([]*model.User, 0, len(dbUsers))
	for _, u := range dbUsers {
		users = append(users, toUserModel(u))
	}

	return users, nil
}

// Mutation returns graph.MutationResolver implementation.
func (r *Resolver) Mutation() graph.MutationResolver { return &mutationResolver{r} }

// Query returns graph.QueryResolver implementation.
func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

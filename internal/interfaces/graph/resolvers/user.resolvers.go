package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	contentApp "blogThree/internal/content/app"
	apperr "blogThree/internal/errors"
	"blogThree/internal/interfaces/graph"
	"blogThree/internal/interfaces/graph/model"
	"blogThree/internal/interfaces/httpctx"
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/google/uuid"
)

// SignUp is the resolver for the signUp field.
func (r *mutationResolver) SignUp(ctx context.Context, input model.SignUpInput) (*model.User, error) {
	user, err := r.UserSvc.SignUp(ctx, input.Email, input.Password)
	if err != nil {
		return nil, err
	}
	return toUserModel(user), nil
}

// SignIn is the resolver for the signIn field.
func (r *mutationResolver) SignIn(ctx context.Context, input model.SignInInput) (*model.AuthPayload, error) {
	user, err := r.UserSvc.SignIn(ctx, input.Email, input.Password)
	if err != nil {
		return nil, err
	}

	tokens, err := r.AuthSvc.GenerateForUser(ctx, user.ID())
	if err != nil {
		return nil, err
	}

	if w, ok := httpctx.ResponseWriter(ctx); ok {
		http.SetCookie(w, &http.Cookie{
			Name:     "refresh_token",
			Value:    tokens.RefreshToken,
			HttpOnly: true,
			Secure:   true,
			SameSite: http.SameSiteStrictMode,
			Path:     "/",
		})
	}

	return &model.AuthPayload{
		User:        toUserModel(user),
		AccessToken: tokens.AccessToken.Value,
	}, nil
}

// SignOut is the resolver for the signOut field.
func (r *mutationResolver) SignOut(ctx context.Context) (bool, error) {
	// 1) Request aus Context holen
	req, ok := httpctx.Request(ctx)
	if !ok {
		// Sollte eigentlich nie passieren, wenn httpctx.Inject korrekt gesetzt ist
		return false, fmt.Errorf("no request in context")
	}

	// 2) Refresh-Cookie lesen
	c, err := req.Cookie("refresh_token")
	if err == nil && c.Value != "" {
		// Versuchen, den Refresh-Token zu revoken.
		// Fehler hier bewusst nicht nach außen leaken -> idempotent & sicher.
		_ = r.AuthSvc.Revoke(ctx, c.Value)
	}

	// 3) Cookie beim Client löschen (auch wenn es oben fehlte -> idempotent)
	if w, ok := httpctx.ResponseWriter(ctx); ok {
		http.SetCookie(w, &http.Cookie{
			Name:     "refresh_token",
			Value:    "",
			Path:     "/",
			HttpOnly: true,
			Secure:   true,
			SameSite: http.SameSiteStrictMode,
			MaxAge:   -1,
			Expires:  time.Unix(0, 0),
		})
	}

	// 4) Immer true zurückgeben:
	// SignOut ist "best effort" und idempotent.
	return true, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context) (*model.AuthPayload, error) {
	req, ok := httpctx.Request(ctx)
	if !ok {
		return nil, fmt.Errorf("no request in context")
	}

	c, err := req.Cookie("refresh_token")
	if err != nil || c.Value == "" {
		return nil, fmt.Errorf("no refresh token")
	}

	tokens, userID, err := r.AuthSvc.Refresh(ctx, c.Value)
	if err != nil {
		return nil, err
	}

	user, err := r.UserSvc.GetByID(ctx, userID)
	if err != nil {
		return nil, err
	}

	if w, ok := httpctx.ResponseWriter(ctx); ok {
		http.SetCookie(w, &http.Cookie{
			Name:     "refresh_token",
			Value:    tokens.RefreshToken,
			HttpOnly: true,
			Secure:   true,
			SameSite: http.SameSiteStrictMode,
			Path:     "/",
		})
	}

	return &model.AuthPayload{
		User:        toUserModel(user),
		AccessToken: tokens.AccessToken.Value,
	}, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	dbUsers, err := r.UserSvc.ListUsers(ctx)
	if err != nil {
		return nil, err
	}

	users := make([]*model.User, 0, len(dbUsers))
	for _, u := range dbUsers {
		users = append(users, toUserModel(u))
	}

	return users, nil
}

// Posts is the resolver for the posts field.
func (r *userResolver) Posts(ctx context.Context, obj *model.User, limit *int32, offset *int32) ([]*model.Post, error) {
	userID, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, apperr.Validation("INVALID_AUTHOR_ID", "invalid author id", map[string]any{
			"id": userID,
		})
	}
	l := 20
	if limit != nil {
		if *limit > 0 && *limit <= 100 {
			l = int(*limit)
		}
	}
	o := 0
	if offset != nil && *offset >= 0 {
		o = int(*offset)
	}
	f := contentApp.PostListFilter{
		Limit:    l,
		Offset:   o,
		AuthorID: &userID,
	}

	// 3) Service call
	posts, err := r.ContentQrySvc.ListPosts(ctx, f)
	if err != nil {
		return nil, err
	}

	// 4) Mapping Domain -> GraphQL
	out := make([]*model.Post, 0, len(posts))
	for _, p := range posts {
		out = append(out, toPostModel(p))
	}
	return out, nil
}

// Mutation returns graph.MutationResolver implementation.
func (r *Resolver) Mutation() graph.MutationResolver { return &mutationResolver{r} }

// Query returns graph.QueryResolver implementation.
func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }

// User returns graph.UserResolver implementation.
func (r *Resolver) User() graph.UserResolver { return &userResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
